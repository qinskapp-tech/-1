<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Arix Signature Interactive Christmas Tree</title>
    
    <!-- Styles -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Playfair+Display:ital,wght@0,400;1,400&display=swap" rel="stylesheet">
    <style>
      body { margin: 0; padding: 0; background-color: #000502; overflow: hidden; }
      #root { width: 100vw; height: 100vh; }
    </style>

    <!-- Import Map for Modules -->
    <script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@18.2.0",
    "react-dom/client": "https://esm.sh/react-dom@18.2.0/client?deps=react@18.2.0",
    "three": "https://esm.sh/three@0.160.0",
    "@react-three/fiber": "https://esm.sh/@react-three/fiber@8.15.16?deps=react@18.2.0,react-dom@18.2.0,three@0.160.0",
    "@react-three/drei": "https://esm.sh/@react-three/drei@9.99.0?deps=react@18.2.0,react-dom@18.2.0,three@0.160.0,@react-three/fiber@8.15.16",
    "@react-three/postprocessing": "https://esm.sh/@react-three/postprocessing@2.16.0?deps=react@18.2.0,react-dom@18.2.0,three@0.160.0,@react-three/fiber@8.15.16",
    "uuid": "https://esm.sh/uuid@9.0.1",
    "react-dom/": "https://esm.sh/react-dom@^19.2.3/",
    "react/": "https://esm.sh/react@^19.2.3/"
  }
}
</script>
    
    <!-- Babel for JSX transpilation in browser -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
<link rel="stylesheet" href="/index.css">
</head>
<body>
    <div id="root"></div>

    <script type="text/babel" data-type="module">
        import React, { useState, useMemo, useRef, useLayoutEffect, Suspense } from 'react';
        import { createRoot } from 'react-dom/client';
        import * as THREE from 'three';
        import { Canvas, useFrame, extend } from '@react-three/fiber';
        import { OrbitControls, Environment, PerspectiveCamera, Stars, shaderMaterial } from '@react-three/drei';
        import { EffectComposer, Bloom, Vignette, Noise } from '@react-three/postprocessing';

        // --- Types / Constants ---
        const TreeState = {
            SCATTERED: 'SCATTERED',
            TREE_SHAPE: 'TREE_SHAPE'
        };

        // --- Components ---

        // 1. Foliage Component
        const FoliageMaterial = shaderMaterial(
            {
                uTime: 0,
                uColorHigh: new THREE.Color('#FFD700'), // Gold
                uColorLow: new THREE.Color('#033820'),  // Deep Emerald
                uMorphFactor: 0, // 0 = Scattered, 1 = Tree
                uPixelRatio: 1,
            },
            // Vertex Shader
            `
            uniform float uTime;
            uniform float uMorphFactor;
            uniform float uPixelRatio;
            
            attribute vec3 aScatterPos;
            attribute vec3 aTreePos;
            attribute float aRandom;
            
            varying float vRandom;
            varying vec3 vPos;

            // Cubic bezier easing for smoother transition
            float easeInOutCubic(float x) {
                return x < 0.5 ? 4.0 * x * x * x : 1.0 - pow(-2.0 * x + 2.0, 3.0) / 2.0;
            }

            void main() {
                vRandom = aRandom;
                
                // Calculate morph progress
                float progress = easeInOutCubic(uMorphFactor);
                
                // Mix positions
                vec3 pos = mix(aScatterPos, aTreePos, progress);
                vPos = pos;

                // Add "breathing" / floating effect
                float breath = sin(uTime * 2.0 + aRandom * 10.0) * 0.05;
                
                // Floating is stronger when scattered
                float floatStrength = mix(1.0, 0.1, progress); 
                pos.y += breath * floatStrength;

                vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                
                // Size attenuation
                gl_Position = projectionMatrix * mvPosition;
                gl_PointSize = (4.0 * uPixelRatio + aRandom * 2.0) * (20.0 / -mvPosition.z);
            }
            `,
            // Fragment Shader
            `
            uniform vec3 uColorHigh;
            uniform vec3 uColorLow;
            varying float vRandom;

            void main() {
                // Circular particle
                vec2 center = gl_PointCoord - 0.5;
                float dist = length(center);
                if (dist > 0.5) discard;

                // Gradient from center (gold/light) to edge (emerald)
                // We flip standard logic: center is bright, edge is dark
                float strength = 1.0 - (dist * 2.0);
                strength = pow(strength, 1.5);

                vec3 color = mix(uColorLow, uColorHigh, strength * 0.8 + vRandom * 0.2);
                
                // Add a glow/alpha falloff
                gl_FragColor = vec4(color, strength);
            }
            `
        );

        extend({ FoliageMaterial });

        const Foliage = ({ treeState }) => {
            const materialRef = useRef(null);
            const count = 8000; // Number of needles
            
            // Target value for morphing
            const targetMorph = treeState === TreeState.TREE_SHAPE ? 1 : 0;

            const data = useMemo(() => {
                const scatterPos = new Float32Array(count * 3);
                const treePos = new Float32Array(count * 3);
                const randoms = new Float32Array(count);

                const scatterRadius = 12;
                const treeHeight = 10;
                const treeBaseRadius = 3.5;

                for (let i = 0; i < count; i++) {
                    // 1. Scattered Position (Random Sphere)
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos((Math.random() * 2) - 1);
                    const r = Math.pow(Math.random(), 1/3) * scatterRadius; // cbrt
                    
                    const xS = r * Math.sin(phi) * Math.cos(theta);
                    const yS = r * Math.sin(phi) * Math.sin(theta);
                    const zS = r * Math.cos(phi);
                    
                    scatterPos[i * 3] = xS;
                    scatterPos[i * 3 + 1] = yS;
                    scatterPos[i * 3 + 2] = zS;

                    // 2. Tree Position (Cone Volume)
                    const yNorm = Math.random(); 
                    const yT = (yNorm - 0.5) * treeHeight;
                    
                    const currentRadius = (1 - yNorm) * treeBaseRadius;
                    
                    const rCone = currentRadius * Math.sqrt(Math.random() * 0.8 + 0.2);
                    const angle = Math.random() * Math.PI * 2;
                    const spiralAngle = angle + yNorm * 10.0;

                    treePos[i * 3] = rCone * Math.cos(spiralAngle);
                    treePos[i * 3 + 1] = yT;
                    treePos[i * 3 + 2] = rCone * Math.sin(spiralAngle);

                    randoms[i] = Math.random();
                }

                return { scatterPos, treePos, randoms };
            }, []);

            useFrame((state, delta) => {
                if (materialRef.current) {
                    materialRef.current.uTime = state.clock.elapsedTime;
                    materialRef.current.uPixelRatio = Math.min(window.devicePixelRatio, 2);
                    
                    const speed = 2.0;
                    materialRef.current.uMorphFactor = THREE.MathUtils.lerp(
                        materialRef.current.uMorphFactor,
                        targetMorph,
                        delta * speed
                    );
                }
            });

            return (
                <points>
                    <bufferGeometry>
                        <bufferAttribute
                            attach="attributes-position"
                            count={count}
                            array={data.scatterPos}
                            itemSize={3}
                        />
                        <bufferAttribute
                            attach="attributes-aScatterPos"
                            count={count}
                            array={data.scatterPos}
                            itemSize={3}
                        />
                        <bufferAttribute
                            attach="attributes-aTreePos"
                            count={count}
                            array={data.treePos}
                            itemSize={3}
                        />
                        <bufferAttribute
                            attach="attributes-aRandom"
                            count={count}
                            array={data.randoms}
                            itemSize={1}
                        />
                    </bufferGeometry>
                    <foliageMaterial ref={materialRef} transparent depthWrite={false} blending={THREE.AdditiveBlending} />
                </points>
            );
        };

        // 2. Ornaments Component
        const Ornaments = ({ treeState }) => {
            const meshRef = useRef(null);
            const giftMeshRef = useRef(null);
            
            const baubleCount = 150;
            const giftCount = 40;
            const dummy = useMemo(() => new THREE.Object3D(), []);

            // --- Baubles Data (Spheres) ---
            const baubles = useMemo(() => {
                const temp = [];
                const scatterRadius = 14;
                const treeHeight = 10;
                const treeBaseRadius = 3.8; 

                for (let i = 0; i < baubleCount; i++) {
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos((Math.random() * 2) - 1);
                    const r = 4 + Math.random() * scatterRadius; 
                    const xS = r * Math.sin(phi) * Math.cos(theta);
                    const yS = r * Math.sin(phi) * Math.sin(theta);
                    const zS = r * Math.cos(phi);

                    const yNorm = Math.random(); 
                    const yT = (yNorm - 0.5) * treeHeight;
                    const currentRadius = (1 - yNorm) * treeBaseRadius;
                    const rCone = currentRadius + 0.1; 
                    const angle = Math.random() * Math.PI * 2;

                    const xT = rCone * Math.cos(angle);
                    const zT = rCone * Math.sin(angle);

                    temp.push({
                        scatterPos: new THREE.Vector3(xS, yS, zS),
                        treePos: new THREE.Vector3(xT, yT, zT),
                        scale: 0.15 + Math.random() * 0.25,
                        color: Math.random() > 0.6 ? '#FFD700' : '#C0C0C0', 
                        speed: 0.5 + Math.random(),
                        phase: Math.random() * Math.PI * 2,
                    });
                }
                return temp;
            }, []);

            // --- Gifts Data (Boxes) ---
            const gifts = useMemo(() => {
                const temp = [];
                const scatterRadius = 8;
                const treeBaseRadius = 4.2; 

                for (let i = 0; i < giftCount; i++) {
                    const theta = Math.random() * Math.PI * 2;
                    const r = Math.random() * scatterRadius;
                    const xS = r * Math.cos(theta);
                    const yS = -5 + Math.random() * 3; 
                    const zS = r * Math.sin(theta);

                    const angle = (i / giftCount) * Math.PI * 2 * 2;
                    const rCone = treeBaseRadius + 0.5 + Math.random() * 1.5;
                    const xT = rCone * Math.cos(angle);
                    const zT = rCone * Math.sin(angle);
                    const yT = -5 + (Math.random() * 1.5);

                    temp.push({
                        scatterPos: new THREE.Vector3(xS, yS, zS),
                        treePos: new THREE.Vector3(xT, yT, zT),
                        scale: 0.4 + Math.random() * 0.4,
                        color: Math.random() > 0.5 ? '#800020' : '#034528',
                        rotation: new THREE.Euler(0, Math.random() * Math.PI, 0),
                    });
                }
                return temp;
            }, []);

            const currentMorph = useRef(0);
            const targetMorph = treeState === TreeState.TREE_SHAPE ? 1 : 0;

            useFrame((state, delta) => {
                currentMorph.current = THREE.MathUtils.lerp(currentMorph.current, targetMorph, delta * 1.5);
                const progress = currentMorph.current;

                if (meshRef.current) {
                    baubles.forEach((data, i) => {
                        const { scatterPos, treePos, scale, speed, phase } = data;
                        
                        const x = THREE.MathUtils.lerp(scatterPos.x, treePos.x, progress);
                        const y = THREE.MathUtils.lerp(scatterPos.y, treePos.y, progress);
                        const z = THREE.MathUtils.lerp(scatterPos.z, treePos.z, progress);
                        
                        const time = state.clock.elapsedTime;
                        const floatAmp = (1 - progress) * 0.5; 
                        const floatY = Math.sin(time * speed + phase) * floatAmp;

                        dummy.position.set(x, y + floatY, z);
                        dummy.scale.setScalar(scale);
                        dummy.rotation.set(0, time * 0.2, 0);
                        dummy.updateMatrix();
                        
                        meshRef.current.setMatrixAt(i, dummy.matrix);
                    });
                    meshRef.current.instanceMatrix.needsUpdate = true;
                }

                if (giftMeshRef.current) {
                    gifts.forEach((data, i) => {
                        const { scatterPos, treePos, scale, rotation } = data;
                        
                        const x = THREE.MathUtils.lerp(scatterPos.x, treePos.x, progress);
                        const y = THREE.MathUtils.lerp(scatterPos.y, treePos.y, progress);
                        const z = THREE.MathUtils.lerp(scatterPos.z, treePos.z, progress);

                        const rotX = THREE.MathUtils.lerp(rotation.x + Math.sin(state.clock.elapsedTime), 0, progress);
                        const rotY = rotation.y;
                        const rotZ = THREE.MathUtils.lerp(rotation.z + Math.cos(state.clock.elapsedTime), 0, progress);

                        dummy.position.set(x, y, z);
                        dummy.rotation.set(rotX, rotY, rotZ);
                        dummy.scale.setScalar(scale);
                        dummy.updateMatrix();

                        giftMeshRef.current.setMatrixAt(i, dummy.matrix);
                    });
                    giftMeshRef.current.instanceMatrix.needsUpdate = true;
                }
            });

            useLayoutEffect(() => {
                if (meshRef.current) {
                    baubles.forEach((data, i) => {
                        meshRef.current.setColorAt(i, new THREE.Color(data.color));
                    });
                    meshRef.current.instanceColor.needsUpdate = true;
                }
                if (giftMeshRef.current) {
                    gifts.forEach((data, i) => {
                        giftMeshRef.current.setColorAt(i, new THREE.Color(data.color));
                    });
                    giftMeshRef.current.instanceColor.needsUpdate = true;
                }
            }, [baubles, gifts]);

            return (
                <React.Fragment>
                    <instancedMesh ref={meshRef} args={[undefined, undefined, baubleCount]} castShadow receiveShadow>
                        <sphereGeometry args={[1, 32, 32]} />
                        <meshStandardMaterial metalness={0.9} roughness={0.1} envMapIntensity={2} />
                    </instancedMesh>

                    <instancedMesh ref={giftMeshRef} args={[undefined, undefined, giftCount]} castShadow receiveShadow>
                        <boxGeometry args={[1, 1, 1]} />
                        <meshStandardMaterial metalness={0.1} roughness={0.6} envMapIntensity={0.5} />
                    </instancedMesh>
                </React.Fragment>
            );
        };

        // 3. TopStar Component
        const TopStar = ({ treeState }) => {
            const meshRef = useRef(null);

            const starShape = useMemo(() => {
                const shape = new THREE.Shape();
                const points = 5;
                const outerRadius = 1.0;
                const innerRadius = 0.5;

                for (let i = 0; i < points * 2; i++) {
                    const r = (i % 2 === 0) ? outerRadius : innerRadius;
                    const angle = (i / (points * 2)) * Math.PI * 2 + Math.PI / 2;
                    
                    const x = Math.cos(angle) * r;
                    const y = Math.sin(angle) * r;
                    
                    if (i === 0) shape.moveTo(x, y);
                    else shape.lineTo(x, y);
                }
                shape.closePath();
                return shape;
            }, []);

            const { scatterPos, treePos } = useMemo(() => {
                const treePos = new THREE.Vector3(0, 5.8, 0);
                
                const r = 10 + Math.random() * 8; 
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                
                const scatterPos = new THREE.Vector3(
                    r * Math.sin(phi) * Math.cos(theta),
                    r * Math.sin(phi) * Math.sin(theta),
                    r * Math.cos(phi)
                );

                return { scatterPos, treePos };
            }, []);

            const currentMorph = useRef(0);
            const targetMorph = treeState === TreeState.TREE_SHAPE ? 1 : 0;

            useFrame((state, delta) => {
                const speed = 1.5;
                currentMorph.current = THREE.MathUtils.lerp(currentMorph.current, targetMorph, delta * speed);
                const progress = currentMorph.current;

                if (meshRef.current) {
                    meshRef.current.position.lerpVectors(scatterPos, treePos, progress);

                    const time = state.clock.elapsedTime;
                    const spinSpeed = 0.5;
                    
                    if (progress > 0.8) {
                        meshRef.current.rotation.x = THREE.MathUtils.lerp(meshRef.current.rotation.x, 0, delta * 2);
                        meshRef.current.rotation.z = THREE.MathUtils.lerp(meshRef.current.rotation.z, 0, delta * 2);
                        meshRef.current.rotation.y += delta * spinSpeed;
                    } else {
                        meshRef.current.rotation.x += delta * 0.2;
                        meshRef.current.rotation.y += delta * 0.2;
                        meshRef.current.rotation.z += delta * 0.1;
                    }

                    const floatAmp = THREE.MathUtils.lerp(0.5, 0.05, progress); 
                    meshRef.current.position.y += Math.sin(time * 1.5) * floatAmp * delta;
                }
            });

            return (
                <mesh ref={meshRef} castShadow receiveShadow>
                    <extrudeGeometry 
                        args={[
                            starShape, 
                            { 
                                depth: 0.3, 
                                bevelEnabled: true, 
                                bevelThickness: 0.1, 
                                bevelSize: 0.05, 
                                bevelSegments: 4 
                            }
                        ]} 
                    />
                    <meshStandardMaterial 
                        color="#FFD700"
                        emissive="#FF8800"
                        emissiveIntensity={0.4}
                        metalness={1.0}
                        roughness={0.1}
                    />
                </mesh>
            );
        };

        // 4. Scene Component
        const Scene = ({ treeState }) => {
            return (
                <Canvas
                    dpr={[1, 2]}
                    gl={{ antialias: false, toneMappingExposure: 1.5 }}
                    shadows
                >
                    <PerspectiveCamera makeDefault position={[0, 2, 25]} fov={45} />
                    <OrbitControls 
                        enablePan={false} 
                        minPolarAngle={Math.PI / 4} 
                        maxPolarAngle={Math.PI / 2}
                        minDistance={10}
                        maxDistance={40}
                        autoRotate={treeState === TreeState.TREE_SHAPE}
                        autoRotateSpeed={0.5}
                    />

                    <ambientLight intensity={0.2} color="#001a10" />
                    
                    <spotLight 
                        position={[0, 20, 0]} 
                        angle={0.6} 
                        penumbra={0.5} 
                        intensity={2} 
                        color="#ffeebb" 
                        castShadow 
                    />
                    
                    <pointLight position={[-10, 5, 10]} intensity={1} color="#00ff88" distance={30} />
                    <pointLight position={[10, -5, -10]} intensity={1} color="#ffaa00" distance={30} />

                    <color attach="background" args={['#010a05']} />
                    <Stars radius={100} depth={50} count={5000} factor={4} saturation={0} fade speed={1} />
                    <Environment preset="city" />

                    <Suspense fallback={null}>
                        <group position={[0, -2, 0]}>
                            <Foliage treeState={treeState} />
                            <Ornaments treeState={treeState} />
                            <TopStar treeState={treeState} />
                        </group>
                    </Suspense>

                    <EffectComposer disableNormalPass>
                        <Bloom 
                            luminanceThreshold={0.8} 
                            mipmapBlur 
                            intensity={1.5} 
                            radius={0.6}
                        />
                        <Vignette eskil={false} offset={0.1} darkness={1.1} />
                        <Noise opacity={0.05} />
                    </EffectComposer>
                </Canvas>
            );
        };

        // 5. Overlay Component
        const Overlay = ({ treeState, setTreeState }) => {
            const isTree = treeState === TreeState.TREE_SHAPE;

            return (
                <div className="absolute inset-0 pointer-events-none flex flex-col justify-between p-8 md:p-12 z-10">
                    {/* Header */}
                    <header className="flex flex-col items-center md:items-start space-y-2">
                        <h1 className="text-3xl md:text-5xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-amber-200 via-yellow-400 to-amber-600 drop-shadow-lg font-serif tracking-widest uppercase">
                            Arix
                        </h1>
                        <h2 className="text-emerald-400/80 text-sm md:text-base tracking-[0.3em] font-light uppercase border-b border-emerald-800 pb-1">
                            Signature Collection
                        </h2>
                    </header>

                    {/* Center Controls */}
                    <div className="absolute bottom-12 left-0 right-0 flex flex-col items-center justify-center space-y-6 pointer-events-auto">
                        <div className="backdrop-blur-md bg-black/30 p-1 rounded-full border border-white/10 shadow-2xl shadow-emerald-900/20">
                            <button
                                onClick={() => setTreeState(isTree ? TreeState.SCATTERED : TreeState.TREE_SHAPE)}
                                className={`
                                    relative px-12 py-4 rounded-full text-sm font-bold tracking-widest uppercase transition-all duration-700 ease-out overflow-hidden group
                                    ${isTree 
                                        ? 'bg-gradient-to-r from-emerald-900 to-black text-emerald-100 hover:text-white border border-emerald-700/50' 
                                        : 'bg-gradient-to-r from-amber-300 via-yellow-500 to-amber-600 text-black shadow-[0_0_40px_rgba(251,191,36,0.4)]'
                                    }
                                `}
                            >
                                <span className="relative z-10">
                                    {isTree ? 'Release Magic' : 'Assemble Tree'}
                                </span>
                                
                                <div className="absolute inset-0 -translate-x-full group-hover:translate-x-full transition-transform duration-1000 bg-gradient-to-r from-transparent via-white/20 to-transparent skew-x-12" />
                            </button>
                        </div>

                        <p className="text-white/40 text-xs font-mono tracking-wider">
                            {isTree ? 'STATE: ASSEMBLED' : 'STATE: ETHEREAL'}
                        </p>
                    </div>
                    
                    {/* Footer / Corner Data */}
                    <div className="hidden md:block absolute bottom-12 right-12 text-right">
                        <div className="text-amber-500/80 font-serif italic text-xl">2025 Edition</div>
                        <div className="text-white/20 text-xs mt-1">Interactive WebGL Experience</div>
                    </div>
                </div>
            );
        };

        // 6. App Component
        const App = () => {
            const [treeState, setTreeState] = useState(TreeState.TREE_SHAPE);

            return (
                <div className="w-full h-screen bg-black relative overflow-hidden font-sans">
                    <div className="absolute inset-0 z-0">
                        <Scene treeState={treeState} />
                    </div>
                    <Overlay treeState={treeState} setTreeState={setTreeState} />
                </div>
            );
        };

        // --- Entry Point ---
        const rootElement = document.getElementById('root');
        const root = createRoot(rootElement);
        root.render(
            <React.StrictMode>
                <App />
            </React.StrictMode>
        );
    </script>
<script type="module" src="/index.tsx"></script>
</body>
</html>